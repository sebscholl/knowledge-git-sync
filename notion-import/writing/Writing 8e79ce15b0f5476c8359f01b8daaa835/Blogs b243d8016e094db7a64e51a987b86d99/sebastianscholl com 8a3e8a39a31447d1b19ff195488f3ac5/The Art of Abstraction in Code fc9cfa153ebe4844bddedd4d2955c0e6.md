# The Art of Abstraction in Code

Created: August 23, 2021 5:50 PM
Location: New York City, United State of America
Original Publish Date: February 21, 2016
Tags: Research, Tech & Code

We're influenced to accept a divide between arts and sciences. A person's bias towards one is often influenced by misunderstanding the other. Scientists are bound to rules and knowledge while artists are limited only by their imaginations. Most would agree with this. However, an artist's brush is beholden to the same laws as any scientific invention. Meaning that the only true difference between them is intention brought to mediums.

The greatest misunderstanding associated with sciences is that there is one way to do things. It's simply not true. Much like art, any scientific endeavor is completely dependent upon the principle, making any result infinitely variable, and arguably, an individualistic pursuit. The divide between art and science is inherently blurred as a developer, being that the code a person writes must be drafted, edited, condensed, re-written, and so forth, no differently than the work of a novelist.

This leads me to a topic I find fascinating; abstraction. Always has abstraction been a term seemingly owned by the arts. Something an art critic understands intimately and an engineer stutters the pronunciation. This may be my own misconception, though I doubt it. The reason being that abstraction lacks detail and science depends on precision, right?

Recently a new definition found me that incorporated a minimalistic approach to necessity. Suggesting that *abstraction* does not lack detail or even embody vagueness, but absolute precision. That quote is:

> Being abstract is something profoundly different from being vague.... The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.— Edsger Dijkstra
> 

Now how's this significant in regards to writing code? Well, a computer interprets code much in the way same a human interprets art, or anything for that matter. The act of interpreting data, whether that data is communicated visually, audibly, physically, or as binary are one in the same. Let's walk through some examples to best explain.

[391,868 bytes]

![Untitled](notion-import/writing/Writing%208e79ce15b0f5476c8359f01b8daaa835/Blogs%20b243d8016e094db7a64e51a987b86d99/sebastianscholl%20com%208a3e8a39a31447d1b19ff195488f3ac5/The%20Art%20of%20Abstraction%20in%20Code%20fc9cfa153ebe4844bddedd4d2955c0e6/Untitled.png)

This painting is not abstract. It is a very literal representation of an apple - but not actually an apple, because it is a painting (and not actually a painting, because it is a photograph...). The purpose of the painting is to make you think "apple". And it does that very well, but not at all efficiently! The artist must have spent days laboring over every fine detail. While this does show artistic skill, it exhausts so many resources to convey such a simple message. The goal is to communicate *apple*. How can we do so with precision?

_THIS WAS AN AUDIO CLIP_

**[72,306 bytes]**

Press play and listen. What did that sound bite - no pun intended - communicate? *Crisp bit into apple*, perhaps? Much like the painting, more data (information) is being communicated than we intended in our message, *apple -* meaning that we are still being inefficient. This audio file is an improvement, though there must be a way for better precision.

[13,308 bytes]

![https://mynamessebastian.files.wordpress.com/2016/02/apple.jpg](https://mynamessebastian.files.wordpress.com/2016/02/apple.jpg)

How about this? An apple's visual abstraction. The first thought that comes to mind when seeing it is *apple -* though it is not an apple, because it is a vector image. The purpose of the vector image is to make you think "apple". And it does that very well, and somewhat efficiently! It’s safe to assume that much fewer resources were exhausted in its making. However, could we go further?

> The fruit of creation.
> 

### **[342 bytes]**

Above is a Jeopardy question. What is the answer? Apple! This short sentence abstracts exactly what we have been intending to communicate. It also does so extremely efficiently. As to give this some quantifiability, I've included each example's file-size from my computer - remember, human memory has limited capacity too! Notice how our original example of the painting took up 391,868 bytes to communicate *apple*, and by becoming more abstract and precise, we've now done so using only 342 bytes. Through abstraction, we were able to be 1146 times more precise! Can we do better? Yes.

> apple
> 

### **[326 bytes]**

"To create a new semantic level in which one can be absolutely precise", we have developed English, and every other language (spoken and written, computer and human). What you see above is a typed out word from the English language. It is an abstract representation of a real world object that we interpret and communicate as *apple.* It is as much an apple as the painting in the first example - being not at all. However, in order to communicate efficiently, we've abstracted what we hear, see, feel, smell and think into languages made up of sounds and characters that form words, which through sounds and markings we hear, see, and feel (braille) before interpreting into our languages.

I hope that all didn't seem a tangent, as this article does have to do with abstraction in code. Creating new semantic levels, or developing languages, is something humans have forever done and will continue to do. All the beauties in life that have come from languages are incalculable. They bond us.

Computer languages are young. Hearing my father speak of computer engineering in the 1970's, I realize that he made due with computer technologies the equivalent of paleolithic agricultural tools. He was there in the beginning. Mustn't it be spectacular to see such development in ones life time? Everything had to be completely explicit, as computer languages we not sophisticated. They had yet created any semantic levels!

The computer languages we use today have been achieved through abstraction. Our ability to develop languages through actualizing higher and higher semantic levels, in which we become more and more precise in communicating. Just as humans have become able to abstract millions of bits of data into *apple, speak,* or *light* and interpret those abstractions as knowledge and/or action, so can a computer. The way we choose to use our languages to communicate with computers? Well, that's up to the developer.